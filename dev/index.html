<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nash.jl · Nash.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Nash.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Nash.jl</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Tutorial-1"><span>Tutorial</span></a></li><li><a class="tocitem" href="#Games-definition-1"><span>Games definition</span></a></li><li><a class="tocitem" href="#Payoff-profile-and-best-reply-1"><span>Payoff profile and best reply</span></a></li><li><a class="tocitem" href="#Nash-equlibria-1"><span>Nash equlibria</span></a></li><li><a class="tocitem" href="#Symmetric-games-1"><span>Symmetric games</span></a></li><li><a class="tocitem" href="#Markov-chain-analysis-1"><span>Markov chain analysis</span></a></li><li><a class="tocitem" href="#Advanced-Nash-equlibria-optimization-1"><span>Advanced Nash equlibria optimization</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Nash.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nash.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KrainskiL/Nash.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Nash.jl-1"><a class="docs-heading-anchor" href="#Nash.jl-1">Nash.jl</a><a class="docs-heading-anchor-permalink" href="#Nash.jl-1" title="Permalink"></a></h1><p><code>Nash.jl</code> is a package providing selected functionalities from game theory field. The package focuses mainly on providing basic functions to define games and finding Nash equilibria.It was created as part of academic game theory course.</p><h1 id="Tutorial-1"><a class="docs-heading-anchor" href="#Tutorial-1">Tutorial</a><a class="docs-heading-anchor-permalink" href="#Tutorial-1" title="Permalink"></a></h1><h2 id="Games-definition-1"><a class="docs-heading-anchor" href="#Games-definition-1">Games definition</a><a class="docs-heading-anchor-permalink" href="#Games-definition-1" title="Permalink"></a></h2><p><code>Nash.jl</code> defines game in package specific format. Currently there are 3 functions supporting game definition:</p><ul><li><code>generate_game</code> - requires payoffs tensor as an argument to create game object with known payoffs values</li><li><code>random_2players_game</code> - creates game object for 2 players with payoffs sampled randomly from provided distribution (from <code>Distributions.jl</code> package)</li><li><code>random_nplayers_game</code> - creates game object for specified number of players with payoffs sampled randomly from provided distribution (from <code>Distributions.jl</code> package)</li></ul><p>For 2-players game with payoffs for first player as follows:</p><ul><li>1 if <em>player1</em> plays first action and <em>player2</em> plays first action</li><li>2 if <em>player1</em> plays first action and <em>player2</em> plays second action</li><li>2.5 if <em>player1</em> plays second action and <em>player2</em> plays first action</li><li>3 if <em>player1</em> plays second action and <em>player2</em> plays second action</li></ul><p>following function call may be used (payoffs for the second player analogous):</p><pre><code class="language-julia">generate_game([1 2; 2.5 3],[2 3;3.5 4])
&gt; Dict{String,Array{Float64,2}} with 2 entries:
&gt;  &quot;player2&quot; =&gt; [2.0 3.0; 3.5 4.0]
&gt;  &quot;player1&quot; =&gt; [1.0 2.0; 2.5 3.0]</code></pre><p>Generation of random 2-players game with payoffs drawn from normal distribution (mean - 0, std - 2), 2 actions for <em>player1</em> and 3 actions for <em>player2</em></p><pre><code class="language-julia">using Distributions
random_2players_game(Normal(0,2),2,3)
&gt; Dict{String,Array{Float64,2}} with 2 entries:
&gt;  &quot;player2&quot; =&gt; [2.80393 -1.9793 -1.52571; -1.50642 -0.0574021 1.0391]
&gt;  &quot;player1&quot; =&gt; [2.2755 -0.224079 0.0240092; 0.466656 -2.85657 2.40831]</code></pre><p>Generation of random 3-players game with payoffs drawn from exponential distribution (mean - 3) and 2 actions for each player</p><pre><code class="language-julia">using Distributions
using Random
Random.seed!(42);

game = random_nplayers_game(Exponential(2),[2,2,2])
&gt; Dict{String,Array{Float64,3}} with 3 entries:
&gt;  &quot;player3&quot; =&gt; [2.22898 0.133327; 2.9479 0.792779]…
&gt;  &quot;player2&quot; =&gt; [7.32142 3.5243; 0.959199 0.619313]…
&gt;  &quot;player1&quot; =&gt; [1.61285 0.307649; 1.20677 0.30259]…</code></pre><h2 id="Payoff-profile-and-best-reply-1"><a class="docs-heading-anchor" href="#Payoff-profile-and-best-reply-1">Payoff profile and best reply</a><a class="docs-heading-anchor-permalink" href="#Payoff-profile-and-best-reply-1" title="Permalink"></a></h2><p>To get payoff profile for game with mixed strategies use <code>get_payoff</code> function. Payoffs for 3-players game defined in Games definition section with 0.5 probability for all players actions:</p><pre><code class="language-julia">get_payoff(game,[[0.5,0.5],[0.5,0.5],[0.5,0.5]])
&gt; Dict{String,Float64} with 3 entries:
&gt;  &quot;player3&quot; =&gt; 1.57951
&gt;  &quot;player2&quot; =&gt; 2.58725
&gt;  &quot;player1&quot; =&gt; 1.25779</code></pre><p><code>best_reply</code> function returns array or convex hull of best replies for <code>k</code>-th player in game with mixed strategies.</p><p>Best response for second player:</p><pre><code class="language-julia">best_reply(game, [[0.5,0.5],[0.5,0.5],[0.5,0.5]],2)
&gt; 1×2 Array{Int64,2}:
&gt; 1  0</code></pre><p>To use convex hull from <code>Polyhedra.jl</code> package specify <code>return_val=&quot;chull&quot;</code>. May take considerable time to finish.</p><pre><code class="language-julia">best_reply(game, [[0.5,0.5],[0.5,0.5],[0.5,0.5]],2, return_val=&quot;chull&quot;)</code></pre><h2 id="Nash-equlibria-1"><a class="docs-heading-anchor" href="#Nash-equlibria-1">Nash equlibria</a><a class="docs-heading-anchor-permalink" href="#Nash-equlibria-1" title="Permalink"></a></h2><p>Given strategies profile for a game <code>is_nash_q</code> checks if the profile is a Nash equilibrium.</p><pre><code class="language-julia">is_nash_q(game, [[0.5,0.5],[0.5,0.5],[0.5,0.5]])</code></pre><p>To iteratively find best profile for each player use <code>iterate_best_reply</code> function. Additional disturbance parameter and number of iterations may be specified.</p><pre><code class="language-julia">iterate_best_reply(game, [[0.5,0.5],[0.5,0.5],[0.5,0.5]],0.,20)</code></pre><h2 id="Symmetric-games-1"><a class="docs-heading-anchor" href="#Symmetric-games-1">Symmetric games</a><a class="docs-heading-anchor-permalink" href="#Symmetric-games-1" title="Permalink"></a></h2><p><code>random_symmetric_2players_game</code> generate random 2-players game with payoffs drawn from specified distribution</p><pre><code class="language-julia">using Random
Random.seed!(42);
symgame = random_symmetric_2players_game(Normal(1,2),2)
&gt; Dict{String,AbstractArray{Float64,2}} with 2 entries:
&gt;  &quot;player2&quot; =&gt; [1.61285 1.20677; 0.307649 0.30259]
&gt;  &quot;player1&quot; =&gt; [1.61285 0.307649; 1.20677 0.30259]</code></pre><p>To find Nash equilibria for symmetric game:</p><pre><code class="language-julia">find_symmetric_nash_equilibrium_2players_game(symgame, [SymPy.Sym(0.5),SymPy.Sym(0.5)])</code></pre><p>To produce symmetries graph use:</p><pre><code class="language-julia">g = create_symmetries_graph([2,2])
&gt; [ Info: Created payout tensor: [((1, 1), 1), ((1, 1), 2), ((1, 2), 1), ((1, 2), 2), ((2, 1), 1), ((2, 1), 2), ((2, 2), 1), ((2, 2), 2)]
&gt; Nash.SymmetriesGraph({8, 4} undirected simple Int64 graph, Dict(((2, 2), 2) =&gt; 8,((1, 1), 1) =&gt; 1,((1, 1), 2) =&gt; 2,((2, 1), 2) =&gt; 6,((1, 2), 2) =&gt; 4,((1, 2), 1) =&gt; 3,((2, 1), 1) =&gt; 5,((2, 2), 1) =&gt; 7), Dict(7 =&gt; ((2, 2), 1),4 =&gt; ((1, 2), 2),2 =&gt; ((1, 1), 2),3 =&gt; ((1, 2), 1),8 =&gt; ((2, 2), 2),5 =&gt; ((2, 1), 1),6 =&gt; ((2, 1), 2),1 =&gt; ((1, 1), 1)))</code></pre><p>To check equality of two payouts in the graph:</p><pre><code class="language-julia">check_equality_condition(g,((1, 1), 1),((2, 1), 1))
&gt; false

check_equality_condition(g,((1, 1), 1),((1, 1), 2))
&gt; true</code></pre><p>To find all nodes with equal payout:</p><pre><code class="language-julia">find_all_equalities(g)
&gt; 4-element Array{Tuple{Tuple{Tuple{Int64,Int64},Int64},Tuple{Tuple{Int64,Int64},Int64}},1}:
&gt; (((1, 1), 1), ((1, 1), 2))
&gt; (((1, 2), 2), ((2, 1), 1))
&gt; (((2, 2), 1), ((2, 2), 2))
&gt; (((1, 2), 1), ((2, 1), 2))</code></pre><h2 id="Markov-chain-analysis-1"><a class="docs-heading-anchor" href="#Markov-chain-analysis-1">Markov chain analysis</a><a class="docs-heading-anchor-permalink" href="#Markov-chain-analysis-1" title="Permalink"></a></h2><p>Game may be represented as Markov chain using <code>game2markov</code> function (2-player games).</p><pre><code class="language-julia">using Random
Random.seed!(42);
game = random_2players_game(Normal(0,1),2,2)
mc = game2markov(game,[[0.5,0.5],[0.5,0.5]])
&gt; Discrete Markov Chain stochastic matrix of type Array{Int64,2}:
&gt; [0 1 0 0; 0 0 0 1; 1 0 0 0; 0 0 1 0]</code></pre><p>To visualize results for 5 steps in produced Markov chain run:</p><pre><code class="language-julia">plot_markov(5,mc)</code></pre><p><img src="https://i.ibb.co/zX2sRmt/Markov-Chain5.png" alt/></p><h2 id="Advanced-Nash-equlibria-optimization-1"><a class="docs-heading-anchor" href="#Advanced-Nash-equlibria-optimization-1">Advanced Nash equlibria optimization</a><a class="docs-heading-anchor-permalink" href="#Advanced-Nash-equlibria-optimization-1" title="Permalink"></a></h2><pre><code class="language-julia">vFunction(game,[[0.5,0.5],[0.5,0.5]])
&gt; 0.421938354571314</code></pre><p>It is not possible to fully implement finding NE through optimization without heavily modifing Julia optimization packages</p><p>The most promising at the time being is Manopt.jl (Manifold Optimization) https://github.com/JuliaManifolds/Manopt.jl using certain data types from Manifolds.jl (https://github.com/JuliaManifolds/Manifolds.jl).</p><p>However, at the time being (06.09.2020) not every manifold type from Manifolds.jl is supported/imported to that library https://github.com/JuliaManifolds/Manopt.jl/blob/master/src/Manopt.jl</p><ul><li>especially not Probability Simplex</li></ul><p>https://github.com/JuliaManifolds/Manifolds.jl/blob/master/src/manifolds/ProbabilitySimplex.jl crucial to finding NE through vFunction optimization</p><p>Other packages are far less advanced - JuMP https://jump.dev/JuMP.jl/v0.21.1/installation/index.html is a Julia frontend for various solvers and solver syntax is the best for that library.</p><p>Optim.jl at the time being supports only very simple manifold constraints and only for first-order algorithms https://julianlsolvers.github.io/Optim.jl/stable/#algo/manifolds/</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 14 September 2020 07:21">Monday 14 September 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
